/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../../lib/primitives.js";
import { safeParse } from "../../../lib/schemas.js";
import { Result as SafeParseResult } from "../../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type HealthRequest = {
  /**
   * Boolean parameter to account for bundle activation status in response. This includes any discovery bundles or bundles defined in the loaded discovery configuration.
   */
  bundles?: boolean | undefined;
  /**
   * Boolean parameter to account for plugin status in response.
   */
  plugins?: boolean | undefined;
  /**
   * String parameter to exclude a plugin from status checks. Can be added multiple times. Does nothing if plugins is not true. This parameter is useful for special use cases where a plugin depends on the server being fully initialized before it can fully initialize itself.
   */
  excludePlugin?: Array<string> | undefined;
};

export type HealthResponse = {
  httpMeta: components.HTTPMetadata;
  /**
   * OPA service is healthy. If the bundles option is specified then all configured bundles have been activated. If the plugins option is specified then all plugins are in an OK state.
   */
  healthyServer?: components.HealthyServer | undefined;
};

/** @internal */
export const HealthRequest$inboundSchema: z.ZodType<
  HealthRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  bundles: z.boolean().default(false),
  plugins: z.boolean().default(false),
  "exclude-plugin": z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "exclude-plugin": "excludePlugin",
  });
});

/** @internal */
export type HealthRequest$Outbound = {
  bundles: boolean;
  plugins: boolean;
  "exclude-plugin"?: Array<string> | undefined;
};

/** @internal */
export const HealthRequest$outboundSchema: z.ZodType<
  HealthRequest$Outbound,
  z.ZodTypeDef,
  HealthRequest
> = z.object({
  bundles: z.boolean().default(false),
  plugins: z.boolean().default(false),
  excludePlugin: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    excludePlugin: "exclude-plugin",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HealthRequest$ {
  /** @deprecated use `HealthRequest$inboundSchema` instead. */
  export const inboundSchema = HealthRequest$inboundSchema;
  /** @deprecated use `HealthRequest$outboundSchema` instead. */
  export const outboundSchema = HealthRequest$outboundSchema;
  /** @deprecated use `HealthRequest$Outbound` instead. */
  export type Outbound = HealthRequest$Outbound;
}

export function healthRequestToJSON(healthRequest: HealthRequest): string {
  return JSON.stringify(HealthRequest$outboundSchema.parse(healthRequest));
}

export function healthRequestFromJSON(
  jsonString: string,
): SafeParseResult<HealthRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthRequest' from JSON`,
  );
}

/** @internal */
export const HealthResponse$inboundSchema: z.ZodType<
  HealthResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  HttpMeta: components.HTTPMetadata$inboundSchema,
  HealthyServer: components.HealthyServer$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "HttpMeta": "httpMeta",
    "HealthyServer": "healthyServer",
  });
});

/** @internal */
export type HealthResponse$Outbound = {
  HttpMeta: components.HTTPMetadata$Outbound;
  HealthyServer?: components.HealthyServer$Outbound | undefined;
};

/** @internal */
export const HealthResponse$outboundSchema: z.ZodType<
  HealthResponse$Outbound,
  z.ZodTypeDef,
  HealthResponse
> = z.object({
  httpMeta: components.HTTPMetadata$outboundSchema,
  healthyServer: components.HealthyServer$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    httpMeta: "HttpMeta",
    healthyServer: "HealthyServer",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace HealthResponse$ {
  /** @deprecated use `HealthResponse$inboundSchema` instead. */
  export const inboundSchema = HealthResponse$inboundSchema;
  /** @deprecated use `HealthResponse$outboundSchema` instead. */
  export const outboundSchema = HealthResponse$outboundSchema;
  /** @deprecated use `HealthResponse$Outbound` instead. */
  export type Outbound = HealthResponse$Outbound;
}

export function healthResponseToJSON(healthResponse: HealthResponse): string {
  return JSON.stringify(HealthResponse$outboundSchema.parse(healthResponse));
}

export function healthResponseFromJSON(
  jsonString: string,
): SafeParseResult<HealthResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HealthResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HealthResponse' from JSON`,
  );
}
